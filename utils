#!/usr/bin/env bash

#######################################
# Color Definitions for Logging
# Description:
#   ANSI color codes for log message formatting.
#######################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

#######################################
# Logging Functions
# Description:
#   Functions to print messages with severity levels and optional logging to file.
#######################################
info() { printf "${BLUE}[INFO]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
success() { printf "${GREEN}[SUCCESS]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
warning() { printf "${YELLOW}[WARNING]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
error() { printf "${RED}[ERROR]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }

fatal() {
  error "$*"
  exit 1
}

error_trap() {
  local exit_code=$?
  local line="$1"
  local cmd="$2"
  error "Command '${cmd}' failed at line ${line} with exit code ${exit_code}"
  exit "$exit_code"
}

#######################################
# Pre-flight Checks
# Description:
#   Functions to ensure the script runs under the correct conditions.
#######################################
require_root() {
  if [[ "$EUID" -ne 0 ]]; then
    fatal "This script must be run as root"
  fi
}

check_dependencies() {
  local deps=(lsblk curl sgdisk partprobe pacstrap arch-chroot numfmt)
  for cmd in "${deps[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      fatal "Required command '$cmd' not found"
    fi
  done
}

#######################################
# Password Prompt
# Description:
#   Prompt the user to type and confirm a password.
# Arguments:
#   $1 = variable name to store password
#######################################
ask_password() {
  local var_name="$1"
  local pass1 pass2

  while true; do
    read -r -sp "Type password: " pass1
    echo
    read -r -sp "Retype password: " pass2
    echo

    if [[ "$pass1" == "$pass2" ]]; then
      printf -v "$var_name" '%s' "$pass1"
      return 0
    else
      echo "Passwords do not match. Please try again."
    fi
  done
}

#######################################
# Yes/No Prompt
# Description:
#   Prompts the user to answer a yes/no question and returns 0 for yes, 1 for no.
# Arguments:
#   $1 = prompt string to display
#######################################
yes_no_prompt() {
  local prompt="$1"
  local reply
  while true; do
    if ! read -rp "$prompt [y/n]: " reply; then
      fatal "Input aborted"
    fi
    case "$reply" in
    [Yy]) return 0 ;;
    [Nn]) return 1 ;;
    esac
    warning "Please answer 'y' or 'n'."
  done
}

update_reflector() {
  local quantity hours seconds
  quantity=15
  hours=24
  seconds=4

  info "Updating reflector"
  reflector \
    --country "${ISO}" \
    --protocol https \
    --completion-percent 100 \
    --age $hours \
    --fastest $quantity \
    --sort rate \
    --threads 8 \
    --download-timeout $seconds \
    --save /etc/pacman.d/mirrorlist
}

#######################################
# Load Package List
# Description:
#   Reads package names from a file, ignoring comments and empty lines.
# Arguments:
#   $1 = path to package list file
# Outputs:
#   stdout = list of packages
#######################################
pkg_list_load() {
  local pkg_file="$1"
  if [[ ! -r "$pkg_file" ]]; then
    echo "Error: package list '$pkg_file' not found or unreadable." >&2
    exit 1
  fi
  grep -vE '^\s*#|^\s*$' "$pkg_file"
}
export -f pkg_list_load

#######################################
# Robust Package Installer
# Description:
#   Installs packages from a list using the specified package manager with retries.
# Arguments:
#   $1 = package manager (default: pacman)
#   $2 = path to package list file
#######################################
function pkg_list_install() {
  local pkgfile="$1"

  if [[ ! -f "$pkgfile" ]]; then
    error "Package list file not found: $pkgfile" >&2
    exit 1
  fi

  local -a packages
  mapfile -t packages < <(pkg_list_load "$pkgfile")
  for attempt in {1..5}; do
    info "Installing packages (attempt $attempt)..."
    if pacman -Syu --noconfirm --needed "${packages[@]}"; then
      success "All packages installed successfully."
      return 0
    else
      sleep 5
    fi
  done

  info "Installation failed after 5." >&2
  exit 1
}
export -f pkg_list_install

pkg_list_multiple_install() {
  local -a list_of_lists=("$@")
  local -a packages_to_install=()

  for list_name in "${list_of_lists[@]}"; do
    local pkglist="${PKG_D}/${list_name}.list"
    if [[ -f "$pkglist" ]]; then
      mapfile -t pkgs < <(load_packages "$pkglist")
      packages_to_install+=("${pkgs[@]}")
    else
      warn "Missing package list: $pkglist"
    fi
  done

  pkg_install "${packages_to_install[@]}"
}
export -f pkg_list_multiple_install
