#!/usr/bin/env bash

#######################################
# Color Definitions for Logging
# Description:
#   ANSI color codes for log message formatting.
#######################################
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

#######################################
# Logging Functions
# Description:
#   Functions to print messages with severity levels and optional logging to file.
#######################################
info() { printf "${BLUE}[INFO]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
success() { printf "${GREEN}[SUCCESS]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
warning() { printf "${YELLOW}[WARNING]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }
error() { printf "${RED}[ERROR]${NC} %s\n" "$*" | tee -a "$LOG_FILE"; }

fatal() {
  error "$*"
  exit 1
}

error_trap() {
  local exit_code=$?
  local line="$1"
  local cmd="$2"
  error "Command '${cmd}' failed at line ${line} with exit code ${exit_code}"
  exit "$exit_code"
}

#######################################
# Pre-flight Checks
# Description:
#   Functions to ensure the script runs under the correct conditions.
#######################################
require_root() {
  if [[ "$EUID" -ne 0 ]]; then
    fatal "This script must be run as root"
  fi
}

check_dependencies() {
  local deps=(lsblk curl sgdisk partprobe pacstrap arch-chroot numfmt)
  for cmd in "${deps[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      fatal "Required command '$cmd' not found"
    fi
  done
}

#######################################
# Password Prompt
# Description:
#   Prompt the user to type and confirm a password.
# Arguments:
#   $1 = variable name to store password
#######################################
ask_password() {
  local var_name="$1"
  local pass1 pass2

  while true; do
    read -r -sp "Type password: " pass1
    echo
    read -r -sp "Retype password: " pass2
    echo

    if [[ "$pass1" == "$pass2" ]]; then
      printf -v "$var_name" '%s' "$pass1"
      return 0
    else
      echo "Passwords do not match. Please try again."
    fi
  done
}

#######################################
# Yes/No Prompt
# Description:
#   Prompts the user to answer a yes/no question and returns 0 for yes, 1 for no.
# Arguments:
#   $1 = prompt string to display
#######################################
yes_no_prompt() {
  local prompt="$1"
  local reply
  while true; do
    if ! read -rp "$prompt [y/n]: " reply; then
      fatal "Input aborted"
    fi
    case "$reply" in
    [Yy]) return 0 ;;
    [Nn]) return 1 ;;
    esac
    warning "Please answer 'y' or 'n'."
  done
}

#######################################
# Country ISO Detection
# Description:
#   Detect the country ISO code via external IP or fallback to LOCALE.
# Outputs:
#   ISO global variable
#######################################
get_country_iso() {
  ISO=$(curl -4 -s ifconfig.co/country-iso)
  if [ -n "$ISO" ]; then
    success "Using ${ISO} as country iso code."
  else
    info "Country ISO not detected, using LOCALE."
    ISO=${LOCALE#*_}
    ISO=${ISO%%.*}
  fi
}

#######################################
# Detect CPU Vendor
# Description:
#   Detects CPU vendor to determine which microcode package to install.
# Globals:
#   CPU_VENDOR
#######################################
detect_cpu() {
  info "Detecting CPU vendor for microcode…"
  if grep -q "GenuineIntel" /proc/cpuinfo; then
    CPU_VENDOR="intel"
  elif grep -q "AuthenticAMD" /proc/cpuinfo; then
    CPU_VENDOR="amd"
  fi
  echo "CPU_VENDOR=${CPU_VENDOR}" >>"$USER_CONF"
  success "CPU Vendor ${CPU_VENDOR} written to ${USER_CONF}"
}

#######################################
# Detect GPU Vendor
# Description:
#   Detects GPU vendor for driver selection.
# Globals:
#   GPU_VENDOR
#######################################
detect_gpu() {
  local gpu_info
  gpu_info=$(lspci)

  info "Detecting GPU vendor…"
  if grep -E "Radeon|AMD" <<<"$gpu_info" && grep -q 'VGA' <<<"$gpu_info"; then
    GPU_VENDOR="amd"
  elif grep -E "NVIDIA|GeForce" <<<"$gpu_info"; then
    GPU_VENDOR="nvidia"
  elif grep -E "Intel.*(Tiger Lake|Alder Lake|Iris Xe|UHD)" <<<"$gpu_info"; then
    GPU_VENDOR="intel"
  fi
  echo "GPU_VENDOR=${GPU_VENDOR}" >>"$USER_CONF"
  success "${GPU_VENDOR} GPU detected and written to ${USER_CONF}"
}

update_reflector() {
  local quantity hours seconds
  quantity=15
  hours=24
  seconds=4

  info "Updating reflector"
  reflector \
    --country "${ISO}" \
    --protocol https \
    --completion-percent 100 \
    --age $hours \
    --fastest $quantity \
    --sort rate \
    --threads 8 \
    --download-timeout $seconds \
    --save /etc/pacman.d/mirrorlist
}

#######################################
# Load Package List
# Description:
#   Reads package names from a file, ignoring comments and empty lines.
# Arguments:
#   $1 = path to package list file
# Outputs:
#   stdout = list of packages
#######################################
load_packages() {
  local pkg_file="$1"
  if [[ ! -r "$pkg_file" ]]; then
    echo "Error: package list '$pkg_file' not found or unreadable." >&2
    exit 1
  fi
  grep -vE '^\s*#|^\s*$' "$pkg_file"
}

#######################################
# Robust Package Installer
# Description:
#   Installs packages from a list using the specified package manager with retries.
# Arguments:
#   $1 = package manager (default: pacman)
#   $2 = path to package list file
#######################################
function pkg_install() {
  local pkgfile="$1"

  if [[ ! -f "$pkgfile" ]]; then
    error "Package list file not found: $pkgfile" >&2
    exit 1
  fi
  local -a packages
  mapfile -t packages < <(load_packages "$pkgfile")

  for attempt in {1..5}; do
    info "Installing packages (attempt $attempt)..."
    if pacman -Syu --noconfirm --needed "${packages[@]}"; then
      success "All packages installed successfully."
      return 0
    else
      sleep 5
    fi
  done

  info "Installation failed after 5." >&2
  exit 1
}
export -f pkg_install
#######################################
# Check if Systemd Unit Exists
# Description:
#   Verifies if a systemd unit exists.
# Arguments:
#   $1 = unit name
#   $2 = mode ("--user" or empty)
# Returns:
#   0 if exists, 1 otherwise
#######################################
unit_exists() {
  local unit="$1"
  local mode="${2:-}" # default to system

  mapfile -t system_units < <(
    systemctl list-unit-files $mode --type=service,timer,socket --no-legend |
      awk '{print $1}'
  )

  for existing in "${system_units[@]}"; do
    if [[ "$unit" == "$existing" ]]; then
      return 0
    fi
  done
  return 1
}

#######################################
# Enable Systemd Units
# Description:
#   Enables an array of systemd units.
# Arguments:
#   $1 = name of array containing unit names
#   $2 = optional mode ("--user")
#######################################
enable_sysd_units() {
  local array_name="$1"
  local mode="${2:-}"

  # Indirect reference to array
  local units
  eval "units=(\"\${${array_name}[@]}\")"

  echo "Enabling (${mode:-system}) units."
  for unit in "${units[@]}"; do
    if unit_exists "$unit" "$mode"; then
      info "Enabling $unit (${mode:-system})"
      systemctl enable $mode "$unit"
    else
      error "Unit $unit not found (${mode:-system})"
    fi
  done
}

#######################################
# Disable Systemd Units
# Description:
#   Disables an array of systemd units.
# Arguments:
#   $1 = name of array containing unit names
#   $2 = optional mode ("--user")
#######################################
disable_sysd_units() {
  local array_name="$1"
  local mode="${2:-}"

  # Indirect reference to array
  local units
  eval "units=(\"\${${array_name}[@]}\")"

  echo "Disabling (${mode:-system}) units."
  for unit in "${units[@]}"; do
    if unit_exists "$unit" "$mode"; then
      info "Disabling $unit (${mode:-system})"
      systemctl disable $mode "$unit"
    else
      error "Unit $unit not found (${mode:-system})"
    fi
  done
}
